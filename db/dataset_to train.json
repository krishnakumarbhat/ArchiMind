[
  {
    "project_name": "Scalable eCommerce Platform",
    "project_goal": "Design a highly available and scalable eCommerce platform capable of handling millions of users and transactions.",
    "design_focus": [
      "Microservices architecture",
      "Asynchronous communication",
      "Distributed transactions",
      "Caching",
      "Fault tolerance"
    ],
    "high_level_design": {
      "architecture_style": "Microservices",
      "key_services": [
        {
          "service_name": "API Gateway",
          "description": "Single entry point handling routing, authentication, and rate limiting."
        },
        {
          "service_name": "User Service",
          "description": "Manages user profiles, authentication (OAuth/JWT), and authorization."
        },
        {
          "service_name": "Product Catalog Service",
          "description": "Manages product information, search, categorization, and media distribution."
        },
        {
          "service_name": "Inventory Service",
          "description": "Maintains stock levels, reservations, and updates with strong consistency."
        },
        {
          "service_name": "Order Service",
          "description": "Orchestrates the order lifecycle and shopping cart management."
        },
        {
          "service_name": "Payment Service",
          "description": "Integrates with payment gateways, processes transactions, and performs fraud checks."
        },
        {
          "service_name": "Shipping Service",
          "description": "Integrates with logistics providers to manage labels and tracking."
        },
        {
          "service_name": "Notification Service",
          "description": "Handles email and mobile notifications for order updates."
        }
      ],
      "data_stores": [
        {
          "store_type": "Relational DB (PostgreSQL/MySQL)",
          "purpose": "Transactional consistency for orders and inventory."
        },
        {
          "store_type": "NoSQL DB (Cassandra/MongoDB)",
          "purpose": "Flexible schema and high read throughput for product catalog."
        },
        {
          "store_type": "Key-Value Cache (Redis/Memcached)",
          "purpose": "Session storage and caching of hot data such as product details."
        },
        {
          "store_type": "Search Engine (Elasticsearch/Solr)",
          "purpose": "Full-text product search and filtering."
        }
      ],
      "communication_mechanisms": [
        {
          "mechanism": "Synchronous (REST/gRPC)",
          "use_case": "Client-to-gateway and read-oriented service communication."
        },
        {
          "mechanism": "Asynchronous (Kafka/RabbitMQ)",
          "use_case": "Order fulfillment workflow and event-driven integrations."
        }
      ],
      "core_flow_example": "Place Order",
      "flow_steps": [
        "Client submits POST /orders to API Gateway.",
        "Gateway forwards the request to Order Service.",
        "Order Service validates cart and emits Order_Created.",
        "Inventory Service reserves stock and emits Stock_Reserved or Stock_Failed.",
        "Order Service marks status pending payment when stock reserved.",
        "Payment Service processes payment and emits success or failure.",
        "Order Service finalizes order as confirmed or cancelled.",
        "Notification Service sends confirmation or failure notification."
      ]
    },
    "low_level_design": {
      "component_name": "Order Service",
      "technology_stack": [
        "Java",
        "Spring Boot",
        "PostgreSQL",
        "Kafka"
      ],
      "data_model": {
        "tables": [
          {
            "name": "orders",
            "fields": [
              {
                "name": "order_id",
                "type": "UUID",
                "constraints": "PRIMARY KEY"
              },
              {
                "name": "user_id",
                "type": "BIGINT",
                "constraints": "FOREIGN KEY"
              },
              {
                "name": "status",
                "type": "VARCHAR(50)",
                "values": [
                  "PENDING",
                  "CONFIRMED",
                  "SHIPPED",
                  "DELIVERED",
                  "CANCELLED"
                ]
              },
              {
                "name": "total_amount",
                "type": "NUMERIC(10,2)"
              },
              {
                "name": "created_at",
                "type": "TIMESTAMP"
              },
              {
                "name": "payment_ref",
                "type": "VARCHAR(100)",
                "constraints": "UNIQUE"
              }
            ],
            "indexes": [
              "user_id",
              "status",
              "created_at"
            ]
          },
          {
            "name": "order_items",
            "fields": [
              {
                "name": "order_item_id",
                "type": "UUID",
                "constraints": "PRIMARY KEY"
              },
              {
                "name": "order_id",
                "type": "UUID",
                "constraints": "FOREIGN KEY"
              },
              {
                "name": "product_id",
                "type": "UUID"
              },
              {
                "name": "quantity",
                "type": "INTEGER"
              },
              {
                "name": "price",
                "type": "NUMERIC(10,2)"
              }
            ]
          }
        ]
      },
      "api_endpoints": [
        {
          "method": "POST",
          "path": "/orders",
          "authentication": "JWT",
          "rate_limit": "5 requests/sec/user",
          "request_body_schema": {
            "user_id": "UUID",
            "items": [
              {
                "product_id": "UUID",
                "quantity": "INTEGER"
              }
            ],
            "shipping_address": "OBJECT"
          }
        },
        {
          "method": "GET",
          "path": "/orders/{order_id}",
          "authentication": "Owner or admin",
          "caching": "Read-through cache via Redis"
        }
      ],
      "async_processing": {
        "topics_produced": [
          "order_events"
        ],
        "topics_consumed": [
          "inventory_events",
          "payment_events",
          "shipping_events"
        ],
        "idempotency_strategy": "Event identifiers prevent duplicate processing"
      },
      "scaling_strategy": "Shard by user_id/order_id with read replicas"
    },
    "sequence_diagram": {
      "name": "Place Order Sequence",
      "participants": [
        "User",
        "API Gateway",
        "Order Service",
        "Inventory Service",
        "Payment Service",
        "Notification Service"
      ],
      "flow": [
        {
          "from": "User",
          "to": "API Gateway",
          "action": "POST /orders"
        },
        {
          "from": "API Gateway",
          "to": "Order Service",
          "action": "Create order"
        },
        {
          "from": "Order Service",
          "to": "Inventory Service",
          "action": "Reserve stock"
        },
        {
          "from": "Inventory Service",
          "to": "Order Service",
          "action": "Stock available"
        },
        {
          "from": "Order Service",
          "to": "Payment Service",
          "action": "Process payment"
        },
        {
          "from": "Payment Service",
          "to": "Order Service",
          "action": "Payment successful"
        },
        {
          "from": "Order Service",
          "to": "Inventory Service",
          "action": "Update stock"
        },
        {
          "from": "Order Service",
          "to": "API Gateway",
          "action": "Return confirmation"
        },
        {
          "from": "API Gateway",
          "to": "User",
          "action": "Send confirmation"
        },
        {
          "from": "Order Service",
          "to": "Notification Service",
          "action": "Send notification"
        }
      ]
    },
    "class_diagram": {
      "name": "eCommerce Class Diagram",
      "classes": [
        {
          "name": "User",
          "attributes": [
            "userId",
            "username",
            "email"
          ],
          "methods": [
            "register",
            "login"
          ]
        },
        {
          "name": "Product",
          "attributes": [
            "productId",
            "name",
            "price",
            "description"
          ]
        },
        {
          "name": "Order",
          "attributes": [
            "orderId",
            "userId",
            "status",
            "totalPrice"
          ],
          "methods": [
            "calculateTotal",
            "updateStatus"
          ]
        },
        {
          "name": "OrderItem",
          "attributes": [
            "orderItemId",
            "productId",
            "quantity",
            "price"
          ]
        },
        {
          "name": "Payment",
          "attributes": [
            "paymentId",
            "orderId",
            "amount",
            "status"
          ]
        }
      ],
      "relationships": [
        {
          "from": "User",
          "to": "Order",
          "type": "One-to-Many"
        },
        {
          "from": "Order",
          "to": "OrderItem",
          "type": "One-to-Many"
        },
        {
          "from": "Product",
          "to": "OrderItem",
          "type": "One-to-Many"
        },
        {
          "from": "Order",
          "to": "Payment",
          "type": "One-to-One"
        }
      ]
    }
  },
  {
    "project_name": "Content Delivery Network (CDN) Architecture",
    "project_goal": "Design a globally distributed CDN to minimize latency and offload origin servers.",
    "design_focus": [
      "Geographically distributed caching",
      "Intelligent request routing",
      "Cache invalidation strategies"
    ],
    "high_level_design": {
      "architecture": "Geographically distributed system",
      "components": [
        {
          "name": "Points of Presence (PoPs)",
          "description": "Regional clusters of cache servers serving local traffic.",
          "responsibilities": [
            "Cache content",
            "Serve users",
            "Aggregate logs"
          ],
          "technology": [
            "Nginx",
            "Varnish"
          ]
        },
        {
          "name": "Origin Server",
          "description": "Authoritative source for content served on cache miss.",
          "technology": [
            "AWS S3",
            "Custom web server"
          ]
        },
        {
          "name": "Request Routing System",
          "description": "Routes users to optimal PoPs based on latency and health.",
          "technology": [
            "GeoDNS",
            "Anycast"
          ]
        },
        {
          "name": "Control Plane",
          "description": "Central configuration, analytics, and SSL management.",
          "interfaces": [
            "REST API",
            "Web dashboard"
          ]
        }
      ],
      "caching_strategy": {
        "policy": "Cache-aside (lazy loading)",
        "eviction": [
          "TTL",
          "LRU"
        ]
      },
      "key_features": [
        "Edge TLS termination",
        "HTTP/2 and HTTP/3 support",
        "DDoS mitigation",
        "Compression"
      ]
    },
    "low_level_design": {
      "component_name": "PoP Cache Server",
      "storage_hierarchy": [
        {
          "level": "L1",
          "type": "In-memory",
          "technology": "Redis/Memcached",
          "purpose": "Store hot content for minimal latency"
        },
        {
          "level": "L2",
          "type": "Persistent SSD",
          "technology": "Nginx proxy cache",
          "purpose": "Persist warm objects beyond memory limits"
        }
      ],
      "cache_eviction": {
        "policy": "LRU",
        "implementation": "Hash map with doubly linked list for O(1) operations"
      },
      "internal_api": [
        {
          "method": "GET",
          "path": "/content?key=<hash>",
          "description": "Fetch from cache, fallback to origin"
        },
        {
          "method": "PUT",
          "path": "/content",
          "description": "Store content with TTL"
        },
        {
          "method": "DELETE",
          "path": "/content?key=<hash>",
          "description": "Purge cached object"
        }
      ]
    },
    "sequence_diagram": {
      "name": "CDN Cache Miss",
      "participants": [
        "User",
        "DNS Resolver",
        "CDN GeoDNS",
        "PoP Cache Server",
        "Origin Server"
      ],
      "flow": [
        {
          "from": "User",
          "to": "DNS Resolver",
          "action": "Resolve content domain"
        },
        {
          "from": "DNS Resolver",
          "to": "CDN GeoDNS",
          "action": "Forward query"
        },
        {
          "from": "CDN GeoDNS",
          "to": "DNS Resolver",
          "action": "Return optimal PoP IP"
        },
        {
          "from": "DNS Resolver",
          "to": "User",
          "action": "Return PoP IP"
        },
        {
          "from": "User",
          "to": "PoP Cache Server",
          "action": "GET asset"
        },
        {
          "from": "PoP Cache Server",
          "to": "Origin Server",
          "action": "Fetch on miss"
        },
        {
          "from": "Origin Server",
          "to": "PoP Cache Server",
          "action": "Return asset"
        },
        {
          "from": "PoP Cache Server",
          "to": "PoP Cache Server",
          "action": "Store with TTL"
        },
        {
          "from": "PoP Cache Server",
          "to": "User",
          "action": "Serve content"
        }
      ]
    },
    "class_diagram": {
      "name": "CDN Class Diagram",
      "classes": [
        {
          "name": "RequestRouter",
          "attributes": [
            "routingRules"
          ],
          "methods": [
            "getBestPoP"
          ]
        },
        {
          "name": "PointOfPresence",
          "attributes": [
            "location",
            "ipRange",
            "healthStatus"
          ],
          "methods": [
            "handleRequest"
          ]
        },
        {
          "name": "CacheServer",
          "attributes": [
            "ramCache",
            "diskCache"
          ],
          "methods": [
            "fetchFromCache",
            "storeInCache",
            "fetchFromOrigin"
          ]
        },
        {
          "name": "CacheObject",
          "attributes": [
            "key",
            "data",
            "ttl",
            "lastAccessed"
          ]
        },
        {
          "name": "OriginServer",
          "attributes": [
            "address"
          ],
          "methods": [
            "getContent"
          ]
        }
      ],
      "relationships": [
        {
          "from": "RequestRouter",
          "to": "PointOfPresence",
          "type": "Directs"
        },
        {
          "from": "PointOfPresence",
          "to": "CacheServer",
          "type": "Composition"
        },
        {
          "from": "CacheServer",
          "to": "CacheObject",
          "type": "Aggregation"
        },
        {
          "from": "CacheServer",
          "to": "OriginServer",
          "type": "Association"
        }
      ]
    }
  },
  {
    "project_name": "Social Networking Platform",
    "project_goal": "Build a scalable social network with personalized feeds, messaging, and notifications.",
    "design_focus": [
      "Microservices decomposition",
      "Hybrid feed fan-out",
      "Real-time messaging",
      "Notification delivery"
    ],
    "high_level_design": {
      "architecture": "Microservices",
      "components": [
        {
          "name": "User & Profile Service",
          "description": "Manages identity, authentication, and profile information.",
          "responsibilities": [
            "Registration/login",
            "Profile CRUD",
            "User settings"
          ],
          "database": "PostgreSQL/MySQL"
        },
        {
          "name": "Social Graph Service",
          "description": "Maintains follower/following relationships and blocks.",
          "responsibilities": [
            "Follow",
            "Unfollow",
            "List followers",
            "Block"
          ],
          "database": "Neo4j/RedisGraph"
        },
        {
          "name": "Post Service",
          "description": "Stores and serves user-generated content.",
          "responsibilities": [
            "CRUD posts",
            "Manage likes and comments"
          ],
          "database": "Cassandra"
        },
        {
          "name": "Feed Service",
          "description": "Generates personalized feeds.",
          "responsibilities": [
            "Aggregate posts",
            "Rank feeds",
            "Fan-out delivery"
          ],
          "database": "Redis",
          "message_stream": "Kafka"
        },
        {
          "name": "Messaging Service",
          "description": "Provides real-time chat capabilities.",
          "responsibilities": [
            "Send messages",
            "Manage history",
            "Track presence"
          ],
          "communication": "WebSockets",
          "database": "Cassandra/HBase"
        },
        {
          "name": "Notification Service",
          "description": "Delivers push and email alerts.",
          "responsibilities": [
            "Generate notifications",
            "Deliver via FCM/APNS"
          ],
          "communication": "Message queue"
        }
      ],
      "api_gateway": {
        "purpose": "Unified entry point for clients",
        "technology": [
          "Kong",
          "AWS API Gateway"
        ]
      }
    },
    "low_level_design": {
      "service_name": "Feed Service",
      "feed_generation_model": {
        "model": "Hybrid fan-out",
        "push_process": {
          "trigger": "User creates a post",
          "steps": [
            "Post Service emits new-post event to Kafka",
            "Feed worker consumes event",
            "Worker fetches followers from Social Graph Service",
            "Redis feed lists updated with post ID"
          ]
        },
        "pull_process": {
          "trigger": "User requests feed",
          "steps": [
            "Retrieve precomputed feed from Redis",
            "Fetch celebrity posts from Post Service",
            "Merge and rank before returning"
          ]
        }
      },
      "api_endpoints": [
        {
          "method": "GET",
          "path": "/feed",
          "description": "Retrieve personalized feed",
          "query_params": [
            "cursor",
            "limit"
          ],
          "response": "Paginated list of posts"
        }
      ]
    },
    "sequence_diagram": {
      "name": "User Post and Feed Fan-out",
      "participants": [
        "User",
        "API Gateway",
        "Post Service",
        "Message Queue",
        "Feed Worker",
        "Social Graph Service",
        "Redis Cache"
      ],
      "flow": [
        {
          "from": "User",
          "to": "API Gateway",
          "action": "POST /posts"
        },
        {
          "from": "API Gateway",
          "to": "Post Service",
          "action": "Create post"
        },
        {
          "from": "Post Service",
          "to": "Post Service",
          "action": "Persist content"
        },
        {
          "from": "Post Service",
          "to": "API Gateway",
          "action": "Return 201"
        },
        {
          "from": "API Gateway",
          "to": "User",
          "action": "Confirm creation"
        },
        {
          "from": "Post Service",
          "to": "Message Queue",
          "action": "Publish post event"
        },
        {
          "from": "Message Queue",
          "to": "Feed Worker",
          "action": "Deliver event"
        },
        {
          "from": "Feed Worker",
          "to": "Social Graph Service",
          "action": "Fetch followers"
        },
        {
          "from": "Social Graph Service",
          "to": "Feed Worker",
          "action": "Return follower list"
        },
        {
          "from": "Feed Worker",
          "to": "Redis Cache",
          "action": "Update feeds"
        }
      ]
    },
    "class_diagram": {
      "name": "Social Media Class Diagram",
      "classes": [
        {
          "name": "User",
          "attributes": [
            "userId",
            "username",
            "email",
            "hashedPassword"
          ],
          "methods": [
            "createPost",
            "follow",
            "sendMessage"
          ]
        },
        {
          "name": "UserProfile",
          "attributes": [
            "profileId",
            "bio",
            "profilePictureUrl",
            "fullName"
          ]
        },
        {
          "name": "Post",
          "attributes": [
            "postId",
            "content",
            "mediaUrl",
            "timestamp",
            "authorId"
          ],
          "methods": [
            "addComment",
            "like"
          ]
        },
        {
          "name": "Comment",
          "attributes": [
            "commentId",
            "text",
            "timestamp",
            "authorId",
            "postId"
          ]
        },
        {
          "name": "Follow",
          "attributes": [
            "followerId",
            "followingId",
            "timestamp"
          ]
        }
      ],
      "relationships": [
        {
          "from": "User",
          "to": "UserProfile",
          "type": "One-to-One"
        },
        {
          "from": "User",
          "to": "Post",
          "type": "One-to-Many"
        },
        {
          "from": "User",
          "to": "Follow",
          "type": "One-to-Many",
          "label": "follower"
        },
        {
          "from": "User",
          "to": "Follow",
          "type": "One-to-Many",
          "label": "following"
        },
        {
          "from": "Post",
          "to": "Comment",
          "type": "One-to-Many"
        }
      ]
    }
  }
]
